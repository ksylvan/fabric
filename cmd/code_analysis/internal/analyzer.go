package internal

import (
	"bufio"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

type Analyzer struct {
	targetDir string
}

type FileStats struct {
	FilePath  string
	Extension string
	LineCount int
	IsLarge   bool
}

type AnalysisResult struct {
	TotalFiles int
	TotalLOC   int
	FilesByExt map[string]int
	LargeFiles []FileStats
	AllFiles   []FileStats
}

const (
	LargeFileThreshold = 500
)

func NewAnalyzer(targetDir string) *Analyzer {
	return &Analyzer{
		targetDir: targetDir,
	}
}

func (a *Analyzer) Analyze() (string, error) {
	result, err := a.collectMetrics()
	if err != nil {
		return "", err
	}

	return a.generateMarkdownReport(result), nil
}

func (a *Analyzer) collectMetrics() (*AnalysisResult, error) {
	result := &AnalysisResult{
		FilesByExt: make(map[string]int),
	}

	err := filepath.Walk(a.targetDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() {
			relPath, err := filepath.Rel(a.targetDir, path)
			if err != nil {
				return err
			}

			parts := strings.Split(relPath, string(filepath.Separator))
			for _, part := range parts {
				if part == "node_modules" || part == "vendor" || part == ".git" || part == ".next" {
					return filepath.SkipDir
				}
			}
			return nil
		}

		ext := strings.ToLower(filepath.Ext(path))
		if a.shouldAnalyzeFile(ext) {
			lineCount, err := a.countLines(path)
			if err != nil {
				fmt.Fprintf(os.Stderr, "Warning: could not read %s: %v\n", path, err)
				return nil
			}

			fileStats := FileStats{
				FilePath:  path,
				Extension: ext,
				LineCount: lineCount,
				IsLarge:   lineCount > LargeFileThreshold,
			}

			result.TotalFiles++
			result.TotalLOC += lineCount
			result.FilesByExt[ext]++
			result.AllFiles = append(result.AllFiles, fileStats)

			if fileStats.IsLarge {
				result.LargeFiles = append(result.LargeFiles, fileStats)
			}
		}

		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("error walking directory: %w", err)
	}

	return result, nil
}

func (a *Analyzer) shouldAnalyzeFile(ext string) bool {
	switch ext {
	case ".go", ".ts", ".tsx", ".js", ".jsx":
		return true
	default:
		return false
	}
}

func (a *Analyzer) countLines(filePath string) (int, error) {
	file, err := os.Open(filePath)
	if err != nil {
		return 0, err
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	count := 0
	for scanner.Scan() {
		count++
	}

	return count, scanner.Err()
}

func (a *Analyzer) generateMarkdownReport(result *AnalysisResult) string {
	var builder strings.Builder

	builder.WriteString("# Code Analysis Report\n\n")
	builder.WriteString(fmt.Sprintf("**Target Directory:** `%s`\n\n", a.targetDir))

	builder.WriteString("## Summary\n\n")
	builder.WriteString(fmt.Sprintf("- **Total Files:** %d\n", result.TotalFiles))
	builder.WriteString(fmt.Sprintf("- **Total Lines of Code:** %d\n", result.TotalLOC))
	builder.WriteString(fmt.Sprintf("- **Large Files (> %d lines):** %d\n", LargeFileThreshold, len(result.LargeFiles)))

	builder.WriteString("\n## Files by Extension\n\n")
	builder.WriteString("| Extension | Count | Percentage |\n")
	builder.WriteString("|-----------|-------|------------|\n")
	for ext, count := range result.FilesByExt {
		percentage := float64(count) / float64(result.TotalFiles) * 100
		builder.WriteString(fmt.Sprintf("| %s | %d | %.1f%% |\n", ext, count, percentage))
	}

	if len(result.LargeFiles) > 0 {
		builder.WriteString("\n## Potentially Large Files\n\n")
		builder.WriteString(fmt.Sprintf("The following files exceed %d lines and may benefit from refactoring:\n\n", LargeFileThreshold))
		for _, file := range result.LargeFiles {
			builder.WriteString(fmt.Sprintf("- `%s` - %d lines\n", file.FilePath, file.LineCount))
		}
	}

	builder.WriteString("\n## File Details\n\n")
	builder.WriteString("| File | Extension | Lines | Large |\n")
	builder.WriteString("|------|-----------|-------|-------|\n")
	for _, file := range result.AllFiles {
		status := "No"
		if file.IsLarge {
			status = "Yes"
		}
		builder.WriteString(fmt.Sprintf("| `%s` | %s | %d | %s |\n", file.FilePath, file.Extension, file.LineCount, status))
	}

	builder.WriteString("\n---\n")
	builder.WriteString(fmt.Sprintf("*Generated by fabric code_analysis tool*\n"))

	return builder.String()
}
